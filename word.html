<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Emergent Blob Simulation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #222;
    color: #fff;
    font-family: sans-serif;
  }
  #worldCanvas {
    display: block;
    margin: 0 auto;
    background-color: #000;
    border: 1px solid #444;
  }
  #info {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    color: #eee;
    background: rgba(0,0,0,0.5);
    padding: 5px;
    font-size: 12px;
    z-index: 10;
  }
</style>
</head>
<body>
<div id="info">Loading...</div>
<canvas id="worldCanvas"></canvas>
<script>
// Canvas and world settings
const canvas = document.getElementById('worldCanvas');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Map parameters
const TILE_SIZE = 32;
const MAP_WIDTH = 50;
const MAP_HEIGHT = 30;

// Tile definitions: 0=water,1=plains,2=forest,3=mountain,4=ruins,5=ice,6=food
let mapData = [];
for (let y = 0; y < MAP_HEIGHT; y++) {
    mapData[y] = [];
    for (let x = 0; x < MAP_WIDTH; x++) {
        mapData[y][x] = 1; // initialize all as plains
    }
}

// Define water at bottom
for (let y = Math.floor(MAP_HEIGHT*0.7); y < MAP_HEIGHT; y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
        mapData[y][x] = 0;
    }
}

// Define a small island in water
const centerX = MAP_WIDTH/2, centerY = MAP_HEIGHT*0.8;
for (let y = Math.floor(MAP_HEIGHT*0.7); y < MAP_HEIGHT; y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
        let dx = x - centerX;
        let dy = y - centerY;
        if (dx*dx + dy*dy < 100) {
            mapData[y][x] = 1; // island plains
        }
    }
}

// Define ruins top-left
for (let y = 0; y < Math.floor(MAP_HEIGHT*0.4); y++) {
    for (let x = 0; x < Math.floor(MAP_WIDTH*0.4); x++) {
        if (Math.random() < 0.2) {
            mapData[y][x] = 4;
        }
    }
}
// Define ice top-right
for (let y = 0; y < Math.floor(MAP_HEIGHT*0.4); y++) {
    for (let x = Math.floor(MAP_WIDTH*0.6); x < MAP_WIDTH; x++) {
        if (Math.random() < 0.7) {
            mapData[y][x] = 5;
        }
    }
}

// Add mountains and forests
for (let y = Math.floor(MAP_HEIGHT*0.4); y < Math.floor(MAP_HEIGHT*0.7); y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
        if (mapData[y][x] === 1 && Math.random() < 0.1) {
            mapData[y][x] = 3;
        }
    }
}
for (let y = 0; y < Math.floor(MAP_HEIGHT*0.7); y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
        if (mapData[y][x] === 1 && Math.random() < 0.2) {
            mapData[y][x] = 2;
        }
    }
}

// Add initial food patches
for (let y = 0; y < MAP_HEIGHT; y++) {
    for (let x = 0; x < MAP_WIDTH; x++) {
        if (mapData[y][x] === 1 && Math.random() < 0.02) {
            mapData[y][x] = 6;
        }
    }
}

// Rendering map with textures
function drawMap() {
    for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
            let tile = mapData[y][x];
            let px = x * TILE_SIZE;
            let py = y * TILE_SIZE;
            if (tile === 0) { // water
                ctx.fillStyle = '#3366cc';
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                // waves
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.beginPath();
                ctx.arc(px + TILE_SIZE/2 + 3*Math.cos((x+y)/5), py + TILE_SIZE/2 + 3*Math.sin((x+y)/5), TILE_SIZE/3, 0, 2*Math.PI);
                ctx.stroke();
            } else if (tile === 1) { // plains
                ctx.fillStyle = '#88aa55';
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                for(let i=0;i<3;i++){
                    ctx.fillStyle = 'rgba(100,140,80,0.8)';
                    let dx = px + Math.random()*TILE_SIZE;
                    let dy = py + Math.random()*TILE_SIZE;
                    ctx.fillRect(dx, dy, 2, 2);
                }
            } else if (tile === 2) { // forest
                ctx.fillStyle = '#557733';
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = '#337733';
                for (let i=0; i<5; i++) {
                    let tx = px + Math.random()*TILE_SIZE;
                    let ty = py + Math.random()*TILE_SIZE;
                    ctx.fillRect(tx, ty, 2, 5);
                    ctx.beginPath();
                    ctx.moveTo(tx - 3, ty);
                    ctx.lineTo(tx + 5, ty);
                    ctx.lineTo(tx + 1, ty - 5);
                    ctx.closePath();
                    ctx.fill();
                }
            } else if (tile === 3) { // mountain
                ctx.fillStyle = '#666644';
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = '#ccccbb';
                ctx.beginPath();
                ctx.moveTo(px, py+TILE_SIZE);
                ctx.lineTo(px+TILE_SIZE/2, py);
                ctx.lineTo(px+TILE_SIZE, py+TILE_SIZE);
                ctx.closePath();
                ctx.fill();
            } else if (tile === 4) { // ruins
                ctx.fillStyle = '#444444';
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = '#222222';
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px+TILE_SIZE, py+TILE_SIZE);
                ctx.moveTo(px, py+TILE_SIZE);
                ctx.lineTo(px+TILE_SIZE, py);
                ctx.stroke();
                ctx.fillStyle = '#555555';
                ctx.fillRect(px+TILE_SIZE/4, py+TILE_SIZE/4, TILE_SIZE/2, TILE_SIZE/2);
            } else if (tile === 5) { // ice
                ctx.fillStyle = '#eeeeff';
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = '#ccccdd';
                ctx.beginPath();
                ctx.moveTo(px, py+TILE_SIZE/2);
                ctx.lineTo(px+TILE_SIZE, py+TILE_SIZE/2);
                ctx.moveTo(px+TILE_SIZE/2, py);
                ctx.lineTo(px+TILE_SIZE/2, py+TILE_SIZE);
                ctx.stroke();
            }
        }
    }
}

// Draw food patches (tile 6)
function drawFood() {
    for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
            if (mapData[y][x] === 6) {
                let px = x * TILE_SIZE, py = y * TILE_SIZE;
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(px+TILE_SIZE/2, py+TILE_SIZE/2, TILE_SIZE/6, 0, 2*Math.PI);
                ctx.fill();
            }
        }
    }
}

// Messages and social simulation
let messages = [];
let godsFaith = {};
let achievements = [];

// Blob entity and behaviors
class Blob {
    constructor(x, y, race) {
        this.x = x;
        this.y = y;
        this.race = race; // 0 or 1
        this.color = race === 0 ? 'orange' : 'lightblue';
        this.hunger = 100;
        this.stamina = 100;
        this.hp = 100;
        this.oxygen = 100;
        this.temperature = 20;
        this.beliefs = {};
    }
    chooseAction() {
        if (this.hunger < 50) return 'seekFood';
        // random wander
        return 'wander';
    }
    performAction(action) {
        if (action === 'wander') {
            this.x += (Math.random()-0.5)*(this.stamina/30);
            this.y += (Math.random()-0.5)*(this.stamina/30);
            this.stamina = Math.max(0, this.stamina - 0.1);
        } else if (action === 'seekFood') {
            this.x += (Math.random()-0.5)*2;
            this.y += (Math.random()-0.5)*2;
        }
        let maxX = MAP_WIDTH*TILE_SIZE;
        let maxY = MAP_HEIGHT*TILE_SIZE;
        if (this.x < 0) this.x = 0;
        if (this.y < 0) this.y = 0;
        if (this.x > maxX) this.x = maxX;
        if (this.y > maxY) this.y = maxY;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, TILE_SIZE/4, 0, 2*Math.PI);
        ctx.fill();
    }
}

// Complex update with needs, healing, and religion
Blob.prototype.update = function() {
    this.hunger -= 0.01;
    if (this.hunger <= 0) {
        this.hp -= 0.1;
    }
    let tileX = Math.floor(this.x / TILE_SIZE);
    let tileY = Math.floor(this.y / TILE_SIZE);
    if (tileY >= Math.floor(MAP_HEIGHT*0.7) && tileX >= 0 && tileX < MAP_WIDTH) {
        this.oxygen -= 0.5;
    } else {
        this.oxygen = Math.min(this.oxygen + 0.2, 100);
    }
    if (this.oxygen <= 0) {
        this.hp -= 0.2;
    }
    // Temperature effects
    if (tileY >= 0 && tileY < MAP_HEIGHT && tileX >= 0 && tileX < MAP_WIDTH) {
        let tile = mapData[tileY][tileX];
        if (tile === 5) {
            this.temperature -= 0.05;
            if (this.temperature < 0) this.hp -= 0.1;
        } else if (tile === 0) {
            this.temperature -= 0.01;
        } else {
            this.temperature += 0.02;
            if (this.temperature > 40) this.hp -= 0.1;
        }
    }
    if (this.hp <= 0) return false;
    let action = this.chooseAction();
    this.performAction(action);
    tileX = Math.floor(this.x / TILE_SIZE);
    tileY = Math.floor(this.y / TILE_SIZE);
    // Eat food on ground
    if (tileY>=0 && tileY<MAP_HEIGHT && tileX>=0 && tileX<MAP_WIDTH) {
        if (mapData[tileY][tileX] === 6 && this.hunger < 80) {
            this.hunger = 100;
            this.stamina = Math.min(this.stamina+10, 100);
            mapData[tileY][tileX] = 1;
            messages.push(this.race === 0 ? "Sallie found food!" : "Rulos found food!");
        }
        // Ritual at ruins
        if (mapData[tileY][tileX] === 4 && Math.random() < 0.005) {
            let god = this.race === 0 ? "FireGod" : "WaterGod";
            this.beliefs[god] = (this.beliefs[god] || 0) + 1;
            godsFaith[god] = (godsFaith[god] || 0) + 1;
            messages.push(this.race === 0 ? "Sallie prays to " + god + "!" : "Rulos prays to " + god + "!");
            // God blessing: spawn food nearby
            if (godsFaith[god] > 10) {
                for (let i=0; i<10; i++) {
                    let rx = tileX + Math.floor((Math.random()-0.5)*10);
                    let ry = tileY + Math.floor((Math.random()-0.5)*10);
                    if (ry>=0 && ry<MAP_HEIGHT && rx>=0 && rx<MAP_WIDTH && mapData[ry][rx]===1) {
                        mapData[ry][rx] = 6;
                        break;
                    }
                }
                achievements.push(god + " blessing!");
                godsFaith[god] = 0;
            }
        }
    }
    return true;
};

// Weather and environment
let raining = false;
let weatherTimer = 0;
function updateWeather() {
    weatherTimer++;
    if (weatherTimer > 1000) {
        weatherTimer = 0;
        raining = Math.random() < 0.3;
        if (raining) {
            messages.push("It starts raining.");
        }
    }
}

// Initialize blobs for two races
let blobs = [];
for (let i=0; i<10; i++) {
    let x = Math.random()*MAP_WIDTH*TILE_SIZE;
    let y = Math.random()*MAP_HEIGHT*TILE_SIZE;
    blobs.push(new Blob(x, y, 0));
}
for (let i=0; i<10; i++) {
    let x = Math.random()*MAP_WIDTH*TILE_SIZE;
    let y = Math.random()*MAP_HEIGHT*TILE_SIZE;
    blobs.push(new Blob(x, y, 1));
}

// Main loop
function loop() {
    updateWeather();
    blobs = blobs.filter(b => b.update());
    drawMap();
    drawFood();
    for (let b of blobs) b.draw();
    // Rain drawing
    if (raining) {
        for (let i=0; i<100; i++) {
            ctx.strokeStyle = 'rgba(180,180,255,0.3)';
            ctx.beginPath();
            let rx = Math.random()*canvas.width;
            let ry = Math.random()*canvas.height;
            ctx.moveTo(rx, ry);
            ctx.lineTo(rx+2, ry+10);
            ctx.stroke();
        }
    }
    // Update info text and messages
    let infoText = "Blobs: " + blobs.length + " | Raining: " + (raining?'Yes':'No');
    if (messages.length > 0) {
        infoText += "<br>" + messages.shift();
    }
    if (achievements.length > 0) {
        infoText += "<br><b>Achievement: " + achievements.shift() + "</b>";
    }
    info.innerHTML = infoText;
    requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>
